\section{Implementation details}


This SANA implementation uses ''bn128'', an ECC implementation that uses an already existing curve belonging to Barreto-Naherig set of curves.
This implementation uses the Barreto-Naehrig curve on a finite field Zp with p of 256 bits.
For the computation of the bilinear map ''bn128'' relies on the Tate-pairing technique which is the fastest for this task. In fact, it requires only one iteration of the Miller's loop function instead of three simplyfying a lot the computation of the pairing.
We chose this implementation because it's a moder versione of an Elliptic-curve cryptosystem used from Ethereum
It's used to generate keys, compute the signatures and verify them.
Our SANA implementation has been written and tested on python 3.7.
It defines a class for each actor in the protocol, they all inherit from the general Node class which contains all the common data structures and functions.
On top of that the classes define:
\begin{itemize}
    \item Owner: method handlerequest() to generate the Token and generateKeys() to generate keys for the new devices.
    \item Verifier: method storeToken() to receive and store the token in the tokenMem field.
    \item Aggregator: method aggregateSignature().
    \item Prover: getSoftConfig() to retrieve its hashed software configuration.
\end{itemize}
These classes are instantiated during the simulation and each object has a set of nodes assigned as neighbours in order to simulate a network of devices.